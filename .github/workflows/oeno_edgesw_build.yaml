name: CI

# Controls when the workflow will run
on:
  # Triggers the workflow on push 
  push:
   branches:
     - dev
     - beta
     - main
  workflow_call:
    inputs:
      APP_NAME:
        type: string
      ARTIFACT_NAME:
        type: string
      ARTIFACT_DESCRIPTION:
        type: string

    secrets:
      envPAT:
        required: true
      PY_KEY:
        required: true
      APP_SIGN_KEY:
        required: true

        
  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

env:
  #BUCKET_NAME : "github-oidc-test-mitch"
  AWS_REGION : "us-east-1"
  PROJECT_FILES_GIT : "beer-project-properties.git"
  ORGANIZATION: "pallcorporation"
  PROJECT_FILES_NAME: "project.properties"
  PROJECT_FILES_DIRECTORY: "project_file"
  CDK_MODULE: "cdk_checkedout"
  DEVOPS_STORE: "devops_store"
  CODEBUILD_BUILD_NUMBER: "1" # semantic versioning injected here
  ARTIFACT_NAME: ${{ inputs.ARTIFACT_NAME }}
  APP_NAME: ${{ inputs.APP_NAME}}
  ARTIFACT_DESCRIPTION: ${{ inputs.ARTIFACT_DESCRIPTION }}
  PY_KEY: ${{ secrets.PY_KEY }}
  APP_SIGN_KEY: ${{ secrets.APP_SIGN_KEY }}
  
permissions:
      id-token: write
      contents: read    # This is required for actions/checkout@v1
      packages: write

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:  
  AWS-WIN-EXE-BUILD:
    if: github.repository != 'pallcorporation/digital-iot-devops-store'
    runs-on: windows-2019
      
    steps:
        # Get current time stamp to use as reference elsewhere
        - name: Get current date
          id: date
          run: |
            $today = Get-Date -format "yyyyMMddHMS"
            echo "::setoutput name=$today"
        
        - name: Git clone the repository
          uses: actions/checkout@v2

         # Get branch name to use for look up
        - name: Branch if Dev
          if: contains( github.ref, 'dev' )
          run: |
            echo "BRANCH_NAME=dev" >> $GITHUB_ENV
        
        - name: Branch if Main
          if: contains( github.ref, 'main' )
          run: |
            echo "BRANCH_NAME=prod" >> $GITHUB_ENV
        
        - name: Branch if BETA
          if: contains( github.ref, 'beta' )
          run: |
            echo "BRANCH_NAME=beta" >> $GITHUB_ENV
            
        
        - name: Echo branch
          run: echo "${BRANCH_NAME} is the branch name to use in lookup"

        # Read of project files and set to variables
        - name: Get project constants from project.properties repo - Branch name, deployment role, skip cdk, destroy stack
          id: project_constants
          run: |
            $pprop = select-string aws_${BRANCH_NAME}_account ${{env.PROJECT_FILES_NAME}}; $account_id = $pprop -split "=",2
            $acc = $account_id[1]
            echo ::set-output name=env_id::$acc
            
            $pprop = select-string aws_${BRANCH_NAME}_oidc_role_name ${{env.PROJECT_FILES_NAME}}; $oidc_role_name = $pprop -split "=",2
            $oidc = $oidc_role_name[1]
            echo ::set-output name=oidc_role::$oidc

            $pprop = select-string aws_${BRANCH_NAME}_cdk_deployment_role ${{env.PROJECT_FILES_NAME}}; $cdk_deploy_role_arn = $pprop -split "=",2
            $cdk = $cdk_deploy_role_arn[1]
            echo ::set-output name=cdk_deploy::$cdk
            
            $pprop = select-string aws_${BRANCH_NAME}_software_bucket ${{env.PROJECT_FILES_NAME}}; $aws_bucket = $pprop -split "=",2
            $bucket = $aws_bucket[1]
            echo ::set-output name=aws_bucket_name::$bucket

        # do a look up by branch for AWS account number
        - name: Configure AWS credentials
          uses: aws-actions/configure-aws-credentials@master
          with:
            role-to-assume: arn:aws:iam::${{steps.project_constants.env_id}}:role/oeno-${{steps.project_constants.oidc_role}}-role
            role-session-name: ${{ github.event.repository.name }}-${{ steps.date.outputs.date }}
            aws-region: ${{ env.AWS_REGION }}

        # # do a look up by branch for AWS account number
        # - name: Configure AWS credentials
        #   uses: aws-actions/configure-aws-credentials@master
        #   with:
        #     role-to-assume: arn:aws:iam::${{ steps.project_constants.outputs.env_id }}:role/oeno-${{ steps.project_constants.outputs.oidc_role}}-role
        #     role-session-name: ${{ github.event.repository.name }}-${{ steps.date.outputs.date }}
        #     aws-region: ${{ env.AWS_REGION }}
        
        #Upload a file to AWS s3
        - name:  Deploy to S3 - Copy Build folder to s3
        #  if: ${{ steps.skip_everything.outputs.skip_everything1 != 'true' && steps.skip_npm.outputs.bypass_npm !='true' && steps.get_deployment_type.outputs.deployment_type == 'web' && steps.get_cdk_destroy_stack.outputs.cdk_destroy_stack != 'true' }}
          run: |
             aws s3 cp readme.md s3://${{steps.project_constants.outputs.aws_bucket}}

        - name: Set up build env
          run: |
            python --version
            python -m venv env
            env\scripts\Activate

        - name: Install dependencies
          run: |    
            env\scripts\pip install -r requirements.txt
            env\scripts\pip install pyinstaller pyinstaller[encryption] tinyaes

        - name: Copy static assets
          run: |
            cp -r env\Lib\site-packages\dash* env\Include
            ls env\Include

        - name: Generate version info 
          run: |
            python generateVersionInfo.py -v "${{env.CODEBUILD_BUILD_NUMBER}}" -n "${{env.APP_NAME}}" -d "${{env.ARTIFACT_DESCRIPTION}}"
            
        - name: Build encrypted exe via Pyinstaller    
          run: |
            cd service
            ..\env\scripts\pyinstaller -y --icon .\assets\icon.ico --version-file .\assets\versioninfo --onefile --add-data "../env/Include;./" --key=${{env.PY_KEY}} ${{ env.APP_NAME }}.py

        - name: Sign application
          run: |
            cd service 
            C:\"Program Files (x86)"\"Windows Kits"\10\bin\x64\signtool.exe sign /debug /F ..\oenoflow_prod.pfx /P ${{ env.APP_SIGN_KEY }} /T http://timestamp.digicert.com ..\service\dist\${{ env.ARTIFACT_NAME }}
        
        - name: Bundle deployment assets
          run: |
            cp .\service\dist\${{ env.ARTIFACT_NAME }} .\ota\${{ env.ARTIFACT_NAME }}
            

        - uses: actions/upload-artifact@v2
          with:
            name: ${{ env.APP_NAME }}
            path: ota/
            
        # Next steps to upload file to S3 softwarepackages- for beta or prod
        # if branch == beta || prod
        #   upload ota/* zip to ^^above archive to packageUpdates/appname

        # - name: Github Tag with semantic versioning
        #   id: version_number
        #   uses: hennejg/github-tag-action@v4.3.1
        #   with:
        #     github_token: ${{ secrets.GITHUB_TOKEN }}
        #     default_bump: minor
        #     tag_prefix: v
        #     release_branches: main

        # - name: Version number
        #   run: |
        #     echo "${{ steps.version_number.outputs.new_version }} is the new version"
        #     echo "TAG_VERSION=${{ steps.version_number.outputs.new_version }}" >> $GITHUB_ENV
        
        # do a look up by branch for AWS account number
        - name: Configure AWS credentials
          uses: aws-actions/configure-aws-credentials@master
          with:
            role-to-assume: arn:aws:iam::142557150669:role/oeno-github-oidc-access-role
            role-session-name: ${{ github.event.repository.name }}-${{ steps.date.outputs.date }}
            aws-region: ${{ env.AWS_REGION }}
        
        #Upload a file to AWS s3
        - name:  Deploy to S3 - Copy Build folder to s3
        #  if: ${{ steps.skip_everything.outputs.skip_everything1 != 'true' && steps.skip_npm.outputs.bypass_npm !='true' && steps.get_deployment_type.outputs.deployment_type == 'web' && steps.get_cdk_destroy_stack.outputs.cdk_destroy_stack != 'true' }}
          run: |
             aws s3 cp readme.md s3://mitch-stage-clone-bucket
              


        

